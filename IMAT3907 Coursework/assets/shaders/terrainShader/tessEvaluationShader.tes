#version 450 core
// The format of the coordinates being outputted by the primitive generator
layout(triangles, equal_spacing, ccw) in;

// Linear interpolation functions for vec3s and vec2s
vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2) ;
vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2) ;

uniform sampler2D[16] u_diffuseMap;

layout(std140) uniform Camera
{
	mat4 u_view;
	mat4 u_projection;
	vec3 u_viewPos;
};

layout(std140) uniform Tessellation
{
	int u_tessellationEquation;
	bool u_generateY;
};

// Unedited vertex data from the TCS
in TCS_OUT {
	vec2 TexCoords;
	flat int TexUnit;
	vec4 Tint;
	vec3 FragPos;
} tes_in[];

// Fragment requires vertex data
out TES_OUT {
	vec3 Normals;
	vec2 TexCoords;
	flat int TexUnit;
	vec4 Tint;
} tes_out;

void main()
{
	float scale = 100.0;
	
   // interpolate the normal and xyz position using the linear interpolation function
   // use 3D because they are in three dimensions; 2D also included for uv texture coordinates
   tes_out.TexCoords = interpolate2D(tes_in[0].TexCoords, tes_in[1].TexCoords, tes_in[2].TexCoords);
   tes_out.TexUnit = tes_in[0].TexUnit;
   tes_out.Tint = tes_in[0].Tint;
   vec3 pos = interpolate3D(tes_in[0].FragPos, tes_in[1].FragPos, tes_in[2].FragPos);
   
   if(u_generateY == true)
   {
		// Use the central difference method to calculate the normals
		float right = (textureOffset(u_diffuseMap[tes_out.TexUnit], tes_out.TexCoords, ivec2(1, 0)).r) * scale;
		float left = (textureOffset(u_diffuseMap[tes_out.TexUnit], tes_out.TexCoords, ivec2(-1, 0)).r) * scale;
		float up = (textureOffset(u_diffuseMap[tes_out.TexUnit], tes_out.TexCoords, ivec2(0, 1)).r) * scale;
		float down = (textureOffset(u_diffuseMap[tes_out.TexUnit], tes_out.TexCoords, ivec2(0, -1)).r) * scale;
	   
		float lr = left - right;
		float du = up - down;
		vec3 Normals = normalize(vec3(lr, 2.0, du));
		
		// Get the height of the vertex by sampling the height map
		// Texture is greyscale so all values are the same
		float height = texture(u_diffuseMap[tes_out.TexUnit], tes_out.TexCoords).r;
		// Must scale up with a scale constant
		pos.y = height * scale;
   }

   // transform vertex position to clip space  - NOTE: WE NEED TO DO IT HERE NOW and not in vertex shader
   gl_Position = u_projection * u_view * vec4(pos, 1.0);
} 

vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2)
{
	// gl_TessCoord is the baycentric coordinate generated
   	return vec2(gl_TessCoord.x) * v0 + vec2(gl_TessCoord.y) * v1 + vec2(gl_TessCoord.z) * v2;
}

vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2)
{
	// gl_TessCoord is the baycentric coordinate generated
   	return vec3(gl_TessCoord.x) * v0 + vec3(gl_TessCoord.y) * v1 + vec3(gl_TessCoord.z) * v2;
}